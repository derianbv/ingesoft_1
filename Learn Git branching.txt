eLevel 1: ----------------------------------------------------------------------------------
-Los commits son snapshots del archivo en ese instante: checkpoints
-Los commits se guardan en el historial de commits.
-Las branches son solo punteros a commits especificos: 

C√ìMO FUNCIONA GIT: 
0. COMMITS (Checkpoint): Son checkpoints en el documento que registran el estado actual de todos los documentos del repositorio (Como ir guardando el proyecto). 
Cuando realizo nuevos commits entonces voy a ir creando un historial de checkpoints A -- B -- C, en realidad van con C: C1 -- C2 -- C3 -- C_n 

1. BRANCH (Puntero a Checkpoint): Cuando creo una branch es simplemente un puntero a un Commit en especifico. 
1.1. A -- B -- C (Main, Head) Ac√° estamos trabajando con la branch Main que es un puntero que apunta al √∫ltimo commit, si yo creo un nuevo commit con "git commit" entonces le hago un snapshot y el historial crece en el sentido en donde apunte HEAD. 

A -- B -- c (MAIN, HEAD) -> git commit -> A -- B -- C -- D (MAIN*). Luego, si creo una nueva branch ("git branch jose") significa que hay dos punteros apuntando a C: A -- B -- C -- D (MAIN*, jose).

1.2. HEAD ("*", Puntero a puntero rama): Head es un puntero que apunta a branches: HEAD -> branch1 -> Commit 4. Esto indica hacia cual de las ramas va a crecer el historial  
C: A -- B -- C -- D (MAIN*, jose)

-EJEMPLO:

[commit A] ‚Üê [commit B] ‚Üê [commit C] ‚Üê Main* 
                             ‚Üë
                           jose

Cambiar de rama: "git checkout jose": 


[commit A] ‚Üê [commit B] ‚Üê [commit C] ‚Üê Main 
                                     ‚Üë
                                   jose*

Ahora HEAD apunta a la rama jose y los nuevos commits ir√°n en esa direcci√≥n: 

git commit -m "nuevo cambio"

[commit A] ‚Üê [commit B] ‚Üê [commit C] ‚Üê main
                                      \
                                       [commit D] ‚Üê jose* 


Level 3: ----------------------------------------------------------------------------------
3.0: Hay dos merge:  1. Merge con commit autom√°tico (la mayor√≠a de los casos),  2. Fast-forward merge (sin nuevo commit)



3.1: MERGE con commit autom√°tico ADELANTADO JALA AL ATRASADO:  SUMA DE LOS COMMITES QUE APUNTAN LAS RAMAS MEZCLADAS: basicamente que  git merge rama1 (desde main) hace un C_rama1 + C_main para crear un C_n+1 que suma los codigos (el texto interno) de  C_rama1 + C_main y mueve el puntero brach que tenga el head hacia este C_n+1. ES DECIR, MERGE HACE UN COMMIT AUTOM√ÅTICO. 

EJEMPLO: 
-Tengo dos branches, main y funcion1, en funcion1 he hecho dos commits extra (C4, C5), me debo pasar a main con checkout y usar git merge funcion1 para crear un nuevo commit que tenga dos commits padres, funcion1 sigue apunto a C5 y main apunta a C6.
Es decir, "git merge rama1" 

C1 -- C2 -- C3 <- (main)
            \
             C4 -- C5 <- (funcion1)*

-"git checkout main" (Mueve el HEAD al puntero main): 

C1 -- C2 -- C3 <- (main)*
            \
             C4 -- C5 <-(funcion1)

-"git merge funcion1" crea un nuevo commit que es la suma de los √∫ltimos commits de ambas ramas (C3 de main + C5 de function = C6 de main), main avanza al C6 porque es el que ten√≠a el HEAD. El puntero branch mergeado solo mergea su commit m√°s no mueve su puntero, es decir, en el ejemplo, funcion1 va a seguir apuntando a C5 que fue su √∫ltimo commit. 

C1 -- C2 -- C3 -------- C6 <-(main)*
          \             /
           C4 -- C5 <-(funcion1)


3.2 "¬øQu√© pasa si regreso a una rama que ya fue mergeada, pero que no se movi√≥ despu√©s del merge (sigue apuntando a su √∫ltimo commit anterior al merge)?": 

"git checkout funcion1" (que pasa el HEAD a funcion1): 

C1 -- C2 -- C3 -------- C6 <-(main)
          \             /
           C4 -- C5 <-(funcion1)*



Y hago un "git commit" creando un nuevo C7 en la l√≠nea de funcion1: 

C1 -- C2 -- C3 -------- C6 <-(main)
          \             /
           C4 ------  C5 -- C7 <-(funcion1)*




y si creo tres m√°s queda algo as√≠: 

C1 -- C2 -- C3 -------- C6 <-(main)
          \             /
           C4 -- C5 -- C7 -- C8 -- C9 -- C10 <-(funcion1)*



üîπ 3.3. Fast-forward merge (sin nuevo commit) EL ATRASADO SE CUELGA DEL ADELANTADO: 
Ac√° como el peque√±o no ha avanzado y sigue un mismo camino, entonces, solo se cambia el puntero atrazado al adelantado. 

C1 -- C2 -- C3 <-(main)
             \
              C4 -- C5 <-(funcion1)*

git checkout main
git merge funcion1


C1 -- C2 -- C3 -- C4 -- C5 <-(main, funcion1)*

De este modo podemos seguir con las ramas que queramos, sirve pensarlo como carreteras que se van bifurcando o uniendo en algun punto

Level 4: ------------------------------------------------------------------------------------------------------------------
