e
eLink: https://learngitbranching.js.org/?locale=es_ES&NODEMO= 

**************************************************************** LOCALES O SINGLE PLAYER *********************************************************************

eLevel 1: ----------------------------------------------------------------------------------
-Los commits son snapshots del archivo en ese instante: checkpoints
-Los commits se guardan en el historial de commits.e
-Las branches son solo punteros a commits especificos: 

C√ìMO FUNCIONA GIT: 
0. COMMITS (Checkpoint): Son checkpoints en el documento que registran el estado actual de todos los documentos del repositorio (Como ir guardando el proyecto). 
Cuando realizo nuevos commits entonces voy a ir creando un historial de checkpoints A -- B -- C, en realidad van con C: C1 -- C2 -- C3 -- C_n 

1. BRANCH (Puntero a Checkpoint): Cuando creo una branch es simplemente un puntero a un Commit en especifico. 
1.1. A -- B -- C (Main, Head) Ac√° estamos trabajando con la branch Main que es un puntero que apunta al √∫ltimo commit, si yo creo un nuevo commit con "git commit" entonces le hago un snapshot y el historial crece en el sentido en donde apunte HEAD. 

A -- B -- c (MAIN, HEAD) -> git commit -> A -- B -- C -- D (MAIN*). Luego, si creo una nueva branch ("git branch jose") significa que hay dos punteros apuntando a C: A -- B -- C -- D (MAIN*, jose).

1.2. HEAD ("*", Puntero a puntero rama o a commit): Head es un puntero que apunta a branches: HEAD -> branch1  (Commit) -> Commit 4. Esto indica hacia cual de las ramas va a crecer el historial  
C: A -- B -- C -- D (MAIN*, jose)


Si es HEAD -> COMMIT: 
-Significa que detachamos el HEAD de alguna rama y lo pusimos en un COMMIT, si queremos hacer "git checkout COMMIT" en realidad tenemos que poner el Hash el commit en espec√≠fico: 
"git checkout fed2da64c0efc5293610bdd892f82a58e8cbc5d8" para ver los hashes se usa "git log"  o ya con "git checkout fed2" git hub deber√≠a reconocerlo 


-EJEMPLO:

[commit A] ‚Üê [commit B] ‚Üê [commit C] ‚Üê Main* 
                             ‚Üë
                           jose

Cambiar de rama: "git checkout jose": 


[commit A] ‚Üê [commit B] ‚Üê [commit C] ‚Üê Main 
                                     ‚Üë
                                   jose*

Ahora HEAD apunta a la rama jose y los nuevos commits ir√°n en esa direcci√≥n: 

git commit -m "nuevo cambio"

[commit A] ‚Üê [commit B] ‚Üê [commit C] ‚Üê main
                                      \
                                       [commit D] ‚Üê jose* 


Level 3: ----------------------------------------------------------------------------------
3.0: Hay dos merge:  1. Merge con commit autom√°tico (la mayor√≠a de los casos),  2. Fast-forward merge (sin nuevo commit)

MAS SENCILLO DE LO QUE PARECE, SIMPLEMENTE JUNTAR LOS CODIGOS Y AVANZAR EN LA BRANCH CON EL HEAD



3.1: MERGE con commit autom√°tico **cuelgo al adelantado o a mismo nivel**:  SUMA DE LOS COMMITES QUE APUNTAN LAS RAMAS MEZCLADAS: basicamente que  git merge rama1 (desde main) hace un C_rama1 + C_main para crear un C_n+1 que suma los codigos (el texto interno) de  C_rama1 + C_main y mueve el puntero brach que tenga el head hacia este C_n+1. ES DECIR, MERGE HACE UN COMMIT AUTOM√ÅTICO. 

EJEMPLO: 
-Tengo dos branches, main y funcion1, en funcion1 he hecho dos commits extra (C4, C5), me debo pasar a main con checkout y usar git merge funcion1 para crear un nuevo commit que tenga dos commits padres, funcion1 sigue apunto a C5 y main apunta a C6.
Es decir, "git merge rama1" 

C1 -- C2 -- C3 <- (main)
            \
             C4 -- C5 <- (funcion1)*

-"git checkout main" (Mueve el HEAD al puntero main): 

C1 -- C2 -- C3 <- (main)*
            \
             C4 -- C5 <-(funcion1)

-"git merge funcion1" crea un nuevo commit que es la suma de los √∫ltimos commits de ambas ramas (C3 de main + C5 de function = C6 de main), main avanza al C6 porque es el que ten√≠a el HEAD. El puntero branch mergeado solo mergea su commit m√°s no mueve su puntero, es decir, en el ejemplo, funcion1 va a seguir apuntando a C5 que fue su √∫ltimo commit. 

C1 -- C2 -- C3 ----------- C6 <-(main)*
            \             /
             C4 -------- C5 <-(funcion1)


3.2 "¬øQu√© pasa si regreso a una rama que ya fue mergeada, pero que no se movi√≥ despu√©s del merge (sigue apuntando a su √∫ltimo commit anterior al merge)?": 

"git checkout funcion1" (que pasa el HEAD a funcion1): 

C1 -- C2 -- C3 -------- C6 <-(main)
          \             /
           C4 -- C5 <-(funcion1)*



Y hago un "git commit" creando un nuevo C7 en la l√≠nea de funcion1: 

C1 -- C2 -- C3 -------- C6 <-(main)
          \             /
           C4 ------  C5 -- C7 <-(funcion1)*




y si creo tres m√°s queda algo as√≠: 

C1 -- C2 -- C3 -------- C6 <-(main)
          \             /
           C4 -- C5 -- C7 -- C8 -- C9 -- C10 <-(funcion1)*



3.3. Fast-forward merge (sin nuevo commit) adelantado jala al atrasado. 
Ac√° como el peque√±o no ha avanzado y sigue un mismo camino, entonces, solo se cambia el puntero atrazado al adelantado. 

C1 -- C2 -- C3 <-(main)
             \
              C4 -- C5 <-(funcion1)*

git checkout main
git merge funcion1


C1 -- C2 -- C3 -- C4 -- C5 <-(main, funcion1)*

De este modo podemos seguir con las ramas que queramos, sirve pensarlo como carreteras que se van bifurcando o uniendo en algun punto




Level 4: ------------------------------------------------------------------------------------------------------------------
REBASE: Aparte del merge, puedo juntar los c√≥digos con Rebase

EPP: Pone los commits que he hecho en una rama x sobre los commits de una rama y a la que le hice rebase. 

EJEMPLO: 

C1 -- C2 -- C3 <-- (main) 
             \ 
              C4 -- C5 (func1*) 

si hago: 
"git checkout func1" (pasar HEAD a func1, aunque en el ejemplo ya est√°) 
"git rebase main": 

C1 -- C2 -- C3 -- C6 <-- (main)                            C1 -- C2 --- C3 -- C6 -- C4' -- C5' 
              \                          -->                                   ‚Üë            ‚Üë
              C4 -- C5 (func1*)                                             (main)       (func1) 

Lo que hace git es que pone todos los commits de esa rama que est√° rebasando sobre el √∫ltimo commit de la rama rebasada. Estos commits (CN') con apostrofo son copias de los normalitos (CN) que a√∫n existen pero a nadie le 
importan. 


El ejemplo anterior da exactamente igual a: 

C1 -- C2 -- C3 -- C6 <-- (main)                           
              \                                              
              C4 -- C5 (func1*)    

"git merge main": 


C1 -- C2 -- C3 ------- C6 <- (main)                           
              \          \                                    
              C4 -- C5 -- C7 <- (func1) 

En ambos ejemplos C5' ==  C7 


Level 5 y 6: ------------------------------------------------------------------------------------------------------------------



Si es HEAD -> COMMIT: 
-Significa que detachamos el HEAD de alguna rama y lo pusimos en un COMMIT, si queremos hacer "git checkout COMMIT" en realidad tenemos que poner el Hash el commit en espec√≠fico: 
"git checkout fed2da64c0efc5293610bdd892f82a58e8cbc5d8" para ver los hashes se usa "git log"  o ya con "git checkout fed2" git hub deber√≠a reconocerlo 

Sin embargo se pueden usar movimientos re posici√≥n relativos: 
1.  Desatacheo el HEAD de la rama actual para que pase de Ejemplo: main* -> C5* 
2. Si me quiero mover un Commit hacia atr√°s ^ o un n√∫mero de commits en especc√≠fico: ~n

Ejemplo: 

C1 -- C2 -- C3 -- C4 
                   ‚Üë
                (main*) 

"git checkout main^^": entonces el Head se va a ir al COMMIT abuelo (abuelo porque hay 2 ^)  de main: 


C1 -- C2 -- C3 -- C4 
       ‚Üë           ‚Üë
      (*)        (main) 

-tambi√©n podemos usar esta notaci√≥n relativa al HEAD: 


C1 -- C2 -- C3 -- C4 
       ‚Üë           ‚Üë
      (*)        (main) 

"git checkout HEAD^": 

 C1 -- C2 -- C3 -- C4 
 ‚Üë                  ‚Üë
(*)               (main) 



Level 7: ------------------------------------------------------------------------------------------------------------------

Uso del ~: 

Ejemplo, el de arriba, pero ahora queremos pasar el HEAD al C1 con un solo comando, no como arriba que usamos varios: 

C1 -- C2 -- C3 -- C4 
                   ‚Üë
                (main*) 

"git checkout HEAD~3": 

 C1 -- C2 -- C3 -- C4 
 ‚Üë                  ‚Üë
(*)               (main) 


Podemos mover una rama a una posici√≥n concreta con la opci√≥n -f, pero siempre tomando como referencia HEAD. Nada de git branch -f func1~3; primero haz git checkout func1 y luego git branch -f main HEAD~3.

C1 -- C2 -- C3 -- C4 
                   ‚Üë
                (main*) 

"git branch -f main HEAD~3": 

 C1 -- C2 -- C3 -- C4 
 ‚Üë                  ‚Üë
(main)             (*) 


Tambi√©n puedo mover ramas independientemente, sabiendo el commit al que quiero ir con su HASH: 


git log: Ver los HASHES. 

git branch -f main hash1234


main va a puntar a hash1234 que es un commit.  

Level 8: ------------------------------------------------------------------------------------------------------------------

REVERTIR CAMBIOS: 
1. git revert, 2. git reset: 

2. git reset (USARLO LOCALMENTE)   
Mueve el puntero chekado un commit atr√°s, o sea el √∫ltimo queda a la deriva, en terminos practicos borra el √∫ltimo commit a lo malecho: 

C1 -- C2 -- C3 -- C4 
                   ‚Üë
                (main*) 

"git reset HEAD~1": 


C1 -- C2 -- C3 -- C4 
            ‚Üë
         (main*) 

1. git revert (USARLO COMPARTIDO): 
Crea un nuevo commmit que revierte los cambios hechos en el Commit previo, as√≠ mantiene el historial intacto. 

C1 -- C2 -- C3 -- C4 
                   ‚Üë
                (main*) 

"git revert HEAD" 

C1 -- C2 -- C3 -- C4 -- C4'
                         ‚Üë
                      (main*) 





| Caracter√≠stica                   | `git reset`                                            | `git revert`                                                    |
| -------------------------------- | ------------------------------------------------------ | --------------------------------------------------------------- |
| ¬øQu√© hace?                       | Mueve la rama y **borra el historial** (si es forzado) | Crea un commit nuevo que "deshace" otro commit                  |
| ¬øAfecta el historial?            | S√≠, **reescribe el historial**                         | No, mantiene el historial intacto                               |
| ¬øEs seguro en repos compartidos? | ‚ùå No seguro (puede romper el historial compartido)     | ‚úÖ Seguro (historia lineal, sin sobrescribir)                    |
| ¬øDeshace cambios?                | S√≠, puede borrar commits por completo                  | S√≠, pero lo hace de forma expl√≠cita y trazable                  |
| ¬øSe puede usar en producci√≥n?    | Solo si est√°s trabajando solo o con ramas locales      | S√≠, es el m√©todo recomendado para revertir en ramas compartidas |





Level 9: ------------------------------------------------------------------------------------------------------------------
CHERRY-PICK: traer un commit y ya, xd robarlo del deck, pero OJO, solo puedo traer de otra rama, nada de padres directos. 
EPP: sirve para implementar commits epecificos en la rama en la que estoy (solo eso) y se copian como nuevos commits, git cherry-pick C1, ..., Cn: 
Ejemplo: 

C1 -- C2 -- C3 -- C6 <-- (main*)                           
              \                                              
              C4 -- C5 -- C7 (func1)    

parado en main, hago 'git cherry-pick C5': 

C1 -- C2 -- C3 -- C6 -- C5'<-- (main*)                           
              \                                              
              C4 -- C5 -- C7 (func1)    

en este caso agrega ese commit en espec√≠fico como uno nuevo


Level 10: ------------------------------------------------------------------------------------------------------------------
Rebase interactivo: 

'git rebase -i HEAD~4'

C1 -- C2 -- C3 -- C4 -- C5 -- C6 <-(main*)
      ‚Üë
    PARED 

con el head~4 digo que voy a setear la pared en el commit actual + 4 hac√≠√° atr√°s, lo que significa que voy a agarrar a todos los commits del camino menos al de la pared, luego voy a poder entrar a un editor de los commits, puedo cambiarlos de orden o dejar de incluir un git, cuando haga cambios van a salir desde el commit pared en adelante como commits primos: C4'. 

Luego de ordenarse o gestionarse de nueva manera, me quedo con una l√≠nea de Cn'y los commits pasados mueres (se vuelven opacos), nadie apunta a ellos


Level 11 y 12: --------------------------------------------------------------------------------------------------------------------
AMEND: corregir errorsitos, tipo, al ultimo commit le saco un commit nuevo y descarto el anterior.
"git commit --amend"


C1 -- C2 -- C3 -- C6

"git commit --amend"

C1 -- C2 -- C3 -- C6' 

y C6 muri√≥ :( 


Level 13: --------------------------------------------------------------------------------------------------------------------
git tag pepito C2 

esto pone una marca a C2 de pepito, lo puedo checkear pero entro solo con la cabeza, y si hago checkouts el tag no se mueve, solo salen commits solitos. 


Level 14: --------------------------------------------------------------------------------------------------------------------
GIT  DESCRIBE: 

Diagrama de ejemplo
===================

           C4--C5--C7           <- func1
          /
C1--C2--C3--C6--C5'             <- main (HEAD)
        |
        v1.0 (tag)

‚Ä¢ v1.0 etiqueta el commit C3.
‚Ä¢ main avanz√≥ a C6 y luego se reescribi√≥ en C5'.
‚Ä¢ func1 se bifurc√≥ en C3 y continu√≥ con commits propios.
git describe en main (HEAD en C5'):

'git describe'
v1.0_2_g<hashC5'>
‚Äì Significa: ‚Äúdos commits por encima de v1.0, en el hash C5'‚Äù.

git describe en func1 (HEAD en C7): 

git checkout func1
git describe:

v1.0_3_g<hashC7>
‚Äì Significa: ‚Äútres commits por encima de v1.0, en el hash C7‚Äù.


Level 15: --------------------------------------------------------------------------------------------------------------------
REBASE CON DOS ARG: 

| Comando              | ¬øQui√©n se mueve? | ¬øQui√©n se queda? |
| -------------------- | ---------------- | ---------------- |
| `git rebase C4 HEAD` | rama `HEAD`      | commit C4 (main) |
| `git rebase HEAD C4` | rama `C4` (main) | commit HEAD      |


Level 16: --------------------------------------------------------------------------------------------------------------------
checkout pap√° si hay 2 y uso posicionamiento relativo (al HEAD): 

si tenemos este caso en donde los papas de C7 son C5 Y C6

C1 -- C2 -- C3 ------- C6 <- (main)                           
              \          \                                    
              C4 -- C5 -- C7 <- (func1*) 

si hago: 'git checkout HEAD~1' pues no sabe porque tiene dos papas, entonces podemos enumerarlos e ir al ^n: 

HEAD^1 ‚Üí C5 porque ac√° se hizo el merge

HEAD^2 ‚Üí C6 y este se trajo con el merge

git checkout HEAD^1 

C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC6   ‚Üê main
        \      \
         C4‚îÄ‚îÄC5‚îÄC7   ‚Üê func1
             ‚Üë
            HEAD (detached)

Level 17: --------------------------------------------------------------------------------------------------------------------
TIRAR MAGIA: DONE B) 



**************************************************************** REMOTE O MUTIPLAYER PLAYER *********************************************************************
eLevel 1: ----------------------------------------------------------------------------------

Los gits remotos en realidad son almacenamiento de informaci√≥n, quiere decir que el proyecto es como una pel√≠cula, y yo la bajo en mi pc entonces ahora est√° guardado ah√≠ para la posteridad. 
En esencia se trata de comunicarse con otro pc. 

-GIT CLONE: 
Copiar un repositorio remoto a local  


repo PC1: 
REMOTO:
C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC6 

"git clone" 

repo PC2: 
LOCAL: 
C1 - - C2 - -C3 - -C6 


Level 2: ----------------------------------------------------------------------------------

-GIT CLONE: 
Copiar un repositorio remoto a local, en este caso, github crea una nueva rama en el repositorio remoto (nube) como especie de etiqueta para remarcar en d√≥nde hab√≠a quedado el proyecto justo antes de que fuera clonado. 


repo PC1: 
C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC6 <- (main)       

"git clone":

repo PC1 (REMOTO): 

C1 - - C2 - -C3 - -C6 <- (main)  

repo PC2 (LOCAL): 

C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC6 <- (origen/main, main)  

ORIGEN: 
En este caso en espec√≠fico podemos hace checkout de este origen/main que se cre√≥ (que es aparte de el main original que ya ten√≠amos), OJO: Esta rama solo se va a mover cuando se actualice el remoto, si trato de meterle un commit, git va a detachear la HEAD y moverse independiente del origen/main: 
origen/rama se crea para todas las ramas que tenga el repo original, no solo para la rama main

EL ORIGEN VIVE EN EL LOCAL Y RECUERDA LA ULTIMA POSICION DEL MAIN REMOTO (ANTES DE PODER STALKEARLO CON FETCH)

repo PC2 (LOCAL): 
C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC6 <- (origen/main, main)  

"git checkout origen/main" 

C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC6 <- (origen/main, main) 
              ‚Üë  
           (HEAD*) 

"git commit" 


C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC6--C7 <- (HEAD*) 
             ‚Üë 
       (origen/main) 

EPP: Origen es como el recuerdo de c√≥mo estaba el repositorio cuando lo clon√©, en realidad es la copia local de la posicion del main remoto al momento de clonar (no maneja internet, es solo un recuerdo), a la hora de realizar fetch que es como stalkear, entonces voy a mirar los commits nuevos (que hacen otras personas con push) y miro en d√≥nde va el main remoto, si este cambio entonces debo actualizar el estado de mi recuerdo (manejado por o/main) y moverlo las posiciones que ha avanzado, eso lo hace autom√°ticamente el git cuando un fetch. 

Digamos que tengo: ------------------------------------------------

repo PC1 (remoto): 
C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC4 <- (main)  

luego lo clono 
repo PC2 (local): 

C1 - - C2 - -C3 - -C4 <- (origen/main, main)  

y hago un git commit con el head en el main del de la nube (remoto) o el otro, se van alternando de n√∫mero creciente, es decir que no pueden existir dos C1 o dos C2 etc., la persona que haga ese commit primero se queda con el numero: 

repo PC1: 
C1‚îÄ‚îÄC2‚îÄ‚îÄC3‚îÄ‚îÄ‚îÄC4 -- C7 -- C9 <- (main) 
repo PC2: 

C1 - - C2 - -C3 - -C4 --C8 -- C10 <- (origen/main, main)  

Level 2 y 3: ---------------------------------------------------------------------------------
GIT FETCH (STALEKAR):  

Es como decir, estoy en mi repo local sano y quiero ver qu√© nuevo ha pasado en el repo remoto,
entonces hago git fetch para traer los cambios a mi pc y poder analizar si me conviene implementarlos con git log. 
Luego si s√≠ me conviene entonces debo hacer un merge. 

EPP: Observo lo nuevo que hay en el repo remoto

FETCH REALIZA: 
1. Va al remoto y comprar mi o/main con el main remoto, si main remoto ha avanzado, entonces EN MI REPO LOCAL se mueve la rama para apuntar a los commits nuevos (es la √∫nica mover la rama) 
2. Mira los commits nuevos que tenga el repo y los descarga en mi repo local (en esencia, pone los commits despues del que estoy trabajando, pero no actualiza la rama actual local, lo cual deja a los commits como fantasmas hasta que yo decida si quiero ir a ellos o no, utilizando un merge o algo as√≠) s


EJEMPLO DE GIT FETCH: 
1.
C1 - - C2 - -C3 - -C4 --C8 -- C10 <- (origen/main, main*)  

2. 
"git fetch"
C1 - - C2 - -C3 - -C4 --C8 -- C10 -- C11 --C12 -- C3 <- (origen/main) 
                               ‚Üë
                            (main*)

En este caso origen apunta los nuevos cambios, pero no entran en vigor, para hacerlos entrar en vigor: 
"git merge origen/main": 

C1 - - C2 - -C3 - -C4 --C8 -- C10 -- C11 --C12 -- C3 <- (origen/main, main*) 



Level 4: ---------------------------------------------------------------------------------
GIT PULL: git fetch + git origen/main 



Level 5: ---------------------------------------------------------------------------------
MAGIA 



Level 6: ---------------------------------------------------------------------------------
git push: 

TODO SUBE, origin/main a la ultima rama (que se subio) y el repo remoto tambien agarra los commits que le pasamos y mueve la rama l final. 


Level 7: ---------------------------------------------------------------------------------

Que pasa si quiero hacer un push a algo desactualizado (que le han metido mano otras perosnas)? 
SOL: 

1. hay: 

REMOTO: 

C1 -- C2 <-- (main)

LOCAL: Considera que el papdre de C3 es C2 

C1 -- C2 -- C3 <-- (bugFix) 
            ‚Üë
      (main/origin)   


2. Luego alg√∫n compa√±ero pushea algo al REMOTO: 

REMOTO: 

C1 -- C2 -- C4 <-- (main)

LOCAL: 

C1 -- C2 -- C3 <-- (bugFix) 
      ‚Üë
(main/origin)   

si yo ahora trato de hacer un push, no voy a poder porque va a tratar de subir C3 pero el padre de C3 QUE ES C2 ahora tiene otro hijo que es C4, recuerda que las ramas solo pueden seguir una sola l√≠nea. 
ERROR: Fast foward 

La manera de solucionarlo tiene mucho sentido: 

hay que: 1. traer los nuevos cambios "git fetch":

REMOTO: 

C1 -- C2 -- C4 <-- (main)

LOCAL: 

C1 -- C2 -- C3 -- C4 <-- (origin/main) 
            ‚Üë
         (bugFix)   


1. rebasar la rama que quer√≠a subir (C3) para que ahora el pap√° sea el COMMIT que me hab√≠a quitado el puesto (C4) "git rebase origin/main": 



REMOTO: 

C1 -- C2 -- C4 <-- (main)

LOCAL: 

C1 -- C2 -- C4 -- C3'  <-- (origin/main) 
                   ‚Üë
                (bugFix)   

Ahora que el commit que quiero subir s√≠ es hijo de √∫ltimo presente en el REMOTO, s√≠ lo puedo pushear con git push: 

REMOTO: 

C1 -- C2 -- C4 -- C3' <-- (main)

LOCAL: 

C1 -- C2 -- C4 -- C3'  <-- (origin/main) 
                   ‚Üë
                (bugFix)   


Puedo hacer todo lo de arriba con una l√≠nea:  git pull --rebase (jala y pone mis commins encima de lo que jal√≥); git push 
Todo esto tambi√©n se puede hacer con merge metiendole mag√≠a. 
O EEP: se puede hacer realizando un git pull (crea un merge de la rama que me quito el lugar y la que quer√≠a subir); git push 


EXPLICACION DE CONFLICTOS DE GIT: --------------------------------------------------------------
Se parte de la idea de que git pull --rebase coge tus cambios y los pone de hijos de los cambios que hicieron los otros, entonces tus cambios deber√≠an basarse en los cambios que hicieron los otros, git analiza esto para poder subir los cambios de la mejor manera mezclando los c√≥digos, la manera en que lo realiza es la siguiente: 

Ahora una explicaci√≥n detallada de Gepeto: 

‚úÖ ¬øQu√© hace Git al hacer un rebase (o merge)?
 Git compara tres versiones:
    üü° El punto base com√∫n (donde ambas ramas se separaron).

    üîµ Tu versi√≥n local (con tus cambios).
    
    üî¥ La versi√≥n remota (con los cambios de tu compa√±ero).

ü§ñ ¬øC√≥mo decide si puede mezclar los cambios autom√°ticamente?
    ‚úÖ Si los cambios est√°n en partes diferentes del archivo:
    Git los mezcla autom√°ticamente.
    No te pregunta nada.

üìÑ Ejemplo:
// archivo.txt antes (en C2)
1: nombre = "Juan"
2: edad = 20
3: ciudad = "Lima"

// tu compa√±ero cambi√≥ l√≠nea 1
1: nombre = "Laura"

// vos cambiaste l√≠nea 3
3: ciudad = "Bogot√°"

‚úîÔ∏è Como los cambios son en l√≠neas diferentes, Git los une sin problema.


‚ùå Si ambos cambiaron la misma l√≠nea:
    Git no puede decidir solo.
    Entonces aparece un conflicto y te dice:
    ‚ÄúAmbos cambiaron la misma parte. ¬øCu√°l quer√©s dejar?‚Äù

// archivo.txt antes (C2)
1: nombre = "Juan"

// cambio remoto
1: nombre = "Laura"

// cambio tuyo
1: nombre = "Carlos"

üëÄ Git no sabe si dejar "Laura" o "Carlos", as√≠ que te muestra esto en el archivo:

<<<<<<< HEAD
nombre = "Carlos"
=======
nombre = "Laura"
>>>>>>> origin/main

Ten√©s que editar manualmente y elegir o combinar, y luego marcar como resuelto.


COMO SOLUCIONAR UN CONFLICTO: --------------------------------------------------------------------------------------------
‚úÖ ‚úÖ ‚úÖ ‚úÖ OPCI√ìN 1: Usar tu editor local (ej: VS Code, Sublime, etc.)
    üõ†Ô∏è 1. Git marca el conflicto en el archivo:
    Supongamos que archivo.txt tiene conflicto. Git lo deja as√≠:
    
    
    <<<<<<< HEAD
    nombre = "Carlos"
    =======
    nombre = "Laura"
    >>>>>>> origin/main
    
    Lo que est√° entre <<<<<<< HEAD y ======= es tu cambio local.
    Lo que est√° entre ======= y >>>>>>> origin/main es el cambio remoto.
    
    ‚úèÔ∏è 2. Vos edit√°s el archivo y dej√°s solo lo que quer√©s, por ejemplo:

    nombre = "Carlos y Laura"
    o simplemente eleg√≠s uno de los dos:
    

    nombre = "Laura"
    ‚úÖ 3. Luego, le dec√≠s a Git que resolviste:

    git add archivo.txt
    git rebase --continue   # si estabas haciendo rebase
    # o
    git merge --continue    # si estabas haciendo merge

‚úÖ‚úÖ‚úÖ‚úÖ   OPCI√ìN 2: Usar Visual Studio Code (lo m√°s f√°cil visualmente)
    Si ten√©s instalado VS Code y abr√≠s el repo con conflicto, te muestra algo as√≠:
    
    üü¶ Te deja elegir entre:
    
    "Accept Current Change" (tu cambio)
    "Accept Incoming Change" (el remoto)
    "Accept Both Changes"
    Editar manualmente
    
    Luego hac√©s lo mismo: git add, git rebase --continue.
    
    ‚öôÔ∏è Si quer√©s que Git siempre abra VS Code cuando hay conflictos:
    git config --global core.editor "code --wait"

‚úÖ‚úÖ‚úÖ‚úÖ OPCI√ìN 3: Usar GitHub (solo para Pull Requests)
    Cuando trabaj√°s con Pull Requests en GitHub y hay conflictos:
    GitHub te muestra un bot√≥n: "Resolve conflicts"
    Ah√≠ pod√©s editar el archivo directamente desde el navegador.
    Guard√°s y hac√©s commit desde ah√≠.
    ‚ùóÔ∏èEsto solo funciona en GitHub cuando hac√©s PRs, no en tu m√°quina local.


